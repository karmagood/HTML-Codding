// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
//
//     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//     1: 1
// 3: 1,3
// 6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.
//
//     What is the value of the first triangle number to have over five hundred divisors?


const nextTriangleNumber = (previousTriangleNumber, indexOfPreviousTriangleNumber) => {
    return previousTriangleNumber + indexOfPreviousTriangleNumber + 1;
};


const listOfSimpleDivisorsWithRepeatings = (arg) => {
    if (arg === 1) return [];
    let divisor = 2;
    let simpleDivisors = []; //init values as this divisors been skipped
    while (arg > 1){
        if (arg % divisor === 0) {
            arg = arg / divisor;
            simpleDivisors.push(divisor);
        }
        else{
            divisor++;
        }
    }
    return simpleDivisors; //because of divisor "1" is not natural number and we have to exclude it from algorithm
};




const lengthesOfConsecutiveSerieses = (sortedValuesList) => {
    let numberOfDifferentValues = [];
    let thisValuesAmount = 1;
    let previousValue;
    for (let el = 0; el < sortedValuesList.length; el ++){
        if (sortedValuesList[el] === previousValue) thisValuesAmount++;
        else{
            if (previousValue !== undefined) numberOfDifferentValues.push(thisValuesAmount);
            thisValuesAmount = 1;
            previousValue = sortedValuesList[el];
        }
    }
    numberOfDifferentValues.push(thisValuesAmount); //last element is out of cycle
    return numberOfDifferentValues;
};

// TODO functionalise
const reduceMultiplyListElems = (numbersList) => {
    let acc = 1;
    for (let el = 0; el < numbersList.length; el++){
        acc *= numbersList[el];
    }
    return acc;
};

const getFirstTriangleNlumberWithNumberOfDivisorsGreaterThen = (maxDivisorsNumber) => {
    // here using 2 step approach ->
    // 1)  from reusing algorithm vith getting list of all simple divisors (it is pretty short and algo runs fast)

    // 2) therefore in deconmposition onto simple divisors we have some amount of different numbers
    // 3) all divisors wll be all combinations of all those numbers (we need only amount of simple divisors of different kind, not their precise values)

    let currentTriangleNumber = 1;
    let orderOfCurrentTriangleNumber = 1;
    let numberOfAllDivisors;
    let numbersOfDifferentValueList;
    do{
        simpleDivisorsList = listOfSimpleDivisorsWithRepeatings(currentTriangleNumber);
        numbersOfDifferentValueList = lengthesOfConsecutiveSerieses(simpleDivisorsList);

        for (let el = 0; el < numbersOfDifferentValueList.length; el++)
            numbersOfDifferentValueList[el] ++ ;

        numberOfAllDivisors = reduceMultiplyListElems(numbersOfDifferentValueList);
        if (numberOfAllDivisors < maxDivisorsNumber) currentTriangleNumber = nextTriangleNumber(currentTriangleNumber, orderOfCurrentTriangleNumber++);
        else break;
    }while (true);

    return currentTriangleNumber;
};

console.log(getFirstTriangleNlumberWithNumberOfDivisorsGreaterThen(5));

console.log(getFirstTriangleNlumberWithNumberOfDivisorsGreaterThen(500));
